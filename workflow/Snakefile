import subprocess
import os
import sys
import glob

##### load paths #####
path_folder_prefix = "/tarafs/scratch/proj5034-AGBKU/catfish"
###
path_reads_prefix = f"{path_folder_prefix}/00-DATA/00-READS"
path_prog_prefix = f"{path_folder_prefix}/01-PROGRAMS"
path_exp_prefix=f"{path_folder_prefix}/02-EXPERIMENTS"
path_out_prefix = f"{path_folder_prefix}/03-OUTPUTS"
path_tmp_prefix = f"{path_folder_prefix}/04-TEMPORARY"


##### setup config and report #####
configfile: "../config/config.yaml"
report: "report/workflow.rst"


##### Definition of functions

def get_unique_values(key):
    values = set()
    for sample in config["samples"].values():
        values.update(sample.get(key, []))
    return list(values)

def get_species():
    return get_unique_values('species_long')

def get_sexes():
    return get_unique_values('sexes')

def get_methods():
    return get_unique_values('methods')

def get_orientations():
    return get_unique_values('orientations')

def get_reference_accession():
    return get_unique_values('')

def get_combined_samples():
    species = get_species()
    sex = get_sexes()
    method = get_methods()
    orientation = get_orientations()
    return ["{}_{}_{}_{}".format(s, sx, m, o) for s in species for sx in sex for m in method for o in orientation]
##### load init rules #####

# Snakemake rules to generate and combine the YAML files

# Rule to generate config_samples.yaml
rule generate_config_samples:
    output:
        "../config/config_samples.yaml"
    shell:
        """
        cd workflow/scripts && python generate_config_samples.py
        """

# Rule to generate config_references.yaml
rule generate_config_references:
    output:
        "../config/config_references.yaml"
    shell:
        """
        cd workflow/scripts && python generate_config_references.py
        """

# Rule to concatenate the yaml files
rule combine_yaml_configs:
    input:
        samples = rules.generate_config_samples.output,
        references = rules.generate_config_references.output,
        params = "../config/params.yaml"
    output:
        "../config/config.yaml"
    shell:
        """
        cat {input.samples} {input.references} {input.params} > {output}
        """

rule all:
    input:
        #Parse metadata outputs
        rules.combine_yaml_configs.output,
        #Mash outputs
        expand(f"{path_out_prefix}/00-MASH/{{sample}}_combined.tbl", 
                sample=get_combined_samples()),
        expand(f"{path_out_prefix}/00-MASH/{{sample}}_screen.out", 
                sample=get_combined_samples()),
        expand(f"{path_out_prefix}/00-MASH/{{sample}}_mash_plot.png", 
                sample=get_combined_samples())
        #FastQC outputs

        #LongQC outputs
        
        #NanoQC outputs

        #Jellyfish histo and genomescope outputs

        #Hifasm outputs
        
        #Greenhill outputs
        
        #mitoVGP assembly pipeline outputs   
##### Main rule to orchestrate the workflow #####
##### load rules #####
#include: "rules/plots.smk"
#include: "rules/reference.smk"
include: "rules/quality_control_reads.smk"
#include: "rules/quality_control_assembly.smk" 
#include: "rules/trimming.smk"
#include: "rules/denovo.smk"

#rule create_assembly_metadata:
#    input:
#        expand("path/to/assemblies/{sample}_assembly.fasta", sample=SAMPLES)
#    output:
#        "assemblies_metadata.yaml"
#    run:
#        import yaml
#
#        assembly_data = {}
#        for sample in SAMPLES:
#            assembly_data[sample] = {"assembly": f"path/to/assemblies/{sample}_assembly.fasta"}
#        
#        with open(output[0], 'w') as outfile:
#            yaml.dump(assembly_data, outfile, default_flow_style=False)



#include: "rules/mapping_illumina.smk"
#include: "rules/variant_calling.smk"

#include: "rules/pangenomes_plots.smk"

#include: "rules/mitoVGP_conda_env_ONT.smk"
#include: "rules/mitoVG_conda_env_pacbio.smk"


#include: "rules/annotations.smk"
#include: "rules/pangenomes_annotations.smk"

#rule create_annotations_metadata:
#    input:
#        expand("path/to/assemblies/{sample}_assembly.fasta", sample=SAMPLES)
#    output:
#        "annotations_metadata.yaml"
#    run:
#        import yaml
#
#        annotation_data = {}
#        for sample in SAMPLES:
#            annotation_data[sample] = {"assembly": f"path/to/assemblies/{sample}_assembly.fasta"}
#        
#        with open(output[0], 'w') as outfile:
#            yaml.dump(annotation_data, outfile, default_flow_style=False)
#
#
# End
