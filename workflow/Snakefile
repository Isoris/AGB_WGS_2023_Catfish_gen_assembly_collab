import subprocess
import os
import sys
import glob
import yaml 
from snakemake.io import expand
from snakemake.io import Wildcards

##### load paths #####
current_path=os.getcwd() 
path_folder_prefix=f"{current_path}/../../.."
#path_folder_prefix=f"/tarafs/scratch/proj5034-AGBKU/catfish" # =  ../../..
###
path_reads_prefix=f"{path_folder_prefix}/00-INPUTS/00-READS"
path_data_prefix=f"{path_folder_prefix}/00-INPUTS"
path_prog_prefix=f"{path_folder_prefix}/01-PROGRAMS"
path_exp_prefix=f"{path_folder_prefix}/02-EXPERIMENTS"
path_out_prefix=f"{path_folder_prefix}/03-OUTPUTS"
path_tmp_prefix=f"{path_folder_prefix}/04-TEMPORARY_FILES"  

##### setup config and report #####
#report: "report/workflow.rst"
threads = 12
configfile: f"{current_path}/config/config.yaml"
print (config['samples'])
# The following is equivalent to what snakemake does with the configuration file:
#config = yaml.load(config_text)
#config


##### Definition of functions

def get_unique_values(key):
    values = set()
    for species in config["samples"].values():
        for sample in species.values():
            value = sample.get(key)
            if value is not None:
                values.add(value)
    return list(values)


def get_unique_values_references(key):
    values = set()
    for sample in config["references"]["references"].values():
        values.update(sample.get(key, []))
    return list(values)

def get_sample_ids():
    return get_unique_values('sample_id')

def get_reference_accession():
    return get_unique_values('assembly_accession')

def get_species_file_prefix():
    return get_unique_values('file_prefixes')

def get_species_long():
    return get_unique_values('species_long')

def get_species():
    return get_unique_values('species')

def get_sex():
    return get_unique_values('sex')

def get_method():
    return get_unique_values('method')

def get_orientation():
    return get_unique_values('orientation')

def get_combined_samples():
    species = get_species()
    sex = get_sex()
    method = get_method()
    orientation = get_orientation()
    return ["{}_{}_{}_{}".format(s, sx, m, o) for s in species for sx in sex for m in method for o in orientation]

def get_sample(wildcards): #Get_sample_prefix
    # This function now assumes each sample is a key in the config that 
    # corresponds to a prefix without a file extension
    return f"{wildcards.species}_{wildcards.sex}_{wildcards.method}_{wildcards.orientation}"


def get_existing_reads_files():
    reads_files = []
    for read_file in glob.glob(f"{path_reads_prefix}/*.fq.gz"):
        if os.path.isfile(read_file):
            # Remove the .fq.gz extension and append the _trimmed.fq.gz extension
            trimmed_base = read_file.rsplit('.fq.gz', 1)[0]
            trimmed_file = f"{trimmed_base}_trimmed.fq.gz"
            reads_files.append(trimmed_file)
    return reads_files

##### load init rules #####

rule all:
    input:
        "paths.sh",
        "logs/logs.txt",
        "logs/file_log.txt",
        "debug_config_output.txt",
        "expand.keys.txt",
        get_existing_reads_files()
        #expand("{path_reads_prefix}/{sample}_trimmed.fq.gz", path_reads_prefix=path_reads_prefix, sample=get_combined_samples()) #line 82
    
        # Add additional lines for other output files as needed


# Rule to print function outputs
rule print_function_outputs:
    output:
        "expand.keys.txt"
    run:
        with open(output[0], 'w') as f_out:
            # List of functions to display output from
            functions_to_run = [
                get_sample_ids,
                get_reference_accession,
                get_species_file_prefix,
                get_species_long,
                get_species,
                get_sex,
                get_method,
                get_orientation,
                get_combined_samples,
            ]
            # Iterate over the functions and print their output
            for func in functions_to_run:
                func_name = func.__name__
                func_output = func()
                print(f"Output of {func_name}: {func_output}")
                f_out.write(f"Output of {func_name}: {func_output}\n")

# Snakefile

# ... [Other parts of your Snakefile] ...

# Rule to write config contents to a file
rule debug_config:
    output:
        debug_config_output="debug_config_output.txt"
    run:
        with open(output.debug_config_output, 'w') as f:
            # Iterate over samples and extract the information
            for species, samples_dict in config['samples'].items():
                for sample_id, sample_info in samples_dict.items():
                    # Write out the details you're interested in
                    f.write(f"Species: {species}, Sample ID: {sample_id}\n")
                    f.write(f"Coverage: {sample_info['coverage']}\n")
                    f.write(f"Description: {sample_info['description']}\n")
                    f.write(f"File Prefix: {sample_info['file_prefix']}\n")
                    f.write(f"Method: {sample_info['method']}\n")
                    f.write(f"Orientation: {sample_info['orientation']}\n")
                    f.write(f"Path Prefix: {sample_info['path_prefix']}\n")
                    f.write(f"Sex: {sample_info['sex']}\n")
                    f.write(f"Species Long: {sample_info['species_long']}\n")
                    f.write("\n")

##### Main rule to orchestrate the workflow #####
rule create_log_folder:
    output:
        log="logs/logs.txt"
    shell:
        "touch {output.log}"

rule export_paths:
    output:
        "paths.sh"
    params:
        path_folder_prefix=path_folder_prefix,  # This assumes path_folder_prefix is a predefined variable
        path_reads_prefix=lambda wc: f"{path_folder_prefix}/00-INPUTS/00-READS",
        path_data_prefix=lambda wc: f"{path_folder_prefix}/00-INPUTS",
        path_prog_prefix=lambda wc: f"{path_folder_prefix}/01-PROGRAMS",
        path_exp_prefix=lambda wc: f"{path_folder_prefix}/02-EXPERIMENTS",
        path_out_prefix=lambda wc: f"{path_folder_prefix}/03-OUTPUTS",
        path_tmp_prefix=lambda wc: f"{path_folder_prefix}/04-TEMPORARY_FILES"
    run:
        with open(str(output), "w") as f:
            f.write(f"export path_reads_prefix='{params.path_reads_prefix}'\n")
            f.write(f"export path_data_prefix='{params.path_data_prefix}'\n")
            f.write(f"export path_prog_prefix='{params.path_prog_prefix}'\n")
            f.write(f"export path_exp_prefix='{params.path_exp_prefix}'\n")
            f.write(f"export path_out_prefix='{params.path_out_prefix}'\n")
            f.write(f"export path_tmp_prefix='{params.path_tmp_prefix}'\n")

rule log_reads_directory:
    input:
        "paths.sh"
    output:
        log="logs/reads_log.txt"
    shell:
        """
        source paths.sh
        echo "Listing .fq, .fastq, .gz, .sam, .bam, .bed, .msh, .fasta, .gfa files in READS directory:" > {output.log}
        find $path_reads_prefix -type f | grep -E '(\.fq|\.fastq|\.sam|\.bam|\.bed|\.msh|\.fasta|\.gfa)$' >> {output.log}
        echo "" >> {output.log}
        """

rule log_data_directory:
    input:
        "paths.sh"
    output:
        log="logs/data_log.txt"
    shell:
        """
        source paths.sh
        echo "Listing .fq, .fastq, .gz, .sam, .bam, .bed, .msh, .fasta, .gfa files in DATA directory:" > {output.log}
        find $path_data_prefix -type f | grep -E '(\.fq|\.fastq|\.sam|\.bam|\.bed|\.msh|\.fasta|\.gfa)$' >> {output.log}
        echo "" >> {output.log}
        """

rule log_experiments_directory:
    output:
        log="logs/experiments_log.txt"
    shell:
        """
        source paths.sh
        echo "Listing .fq, .fastq, .gz, .sam, .bam, .bed, .msh, .fasta, .gfa files in EXPERIMENTS directory:" > {output.log}
        find $path_exp_prefix -type f | grep -E '(\.fq|\.fastq|\.sam|\.bam|\.bed|\.msh|\.fasta|\.gfa)$' >> {output.log}
        echo "" >> {output.log}
        """

rule log_programs_directory:
    output:
        log="logs/programs_log.txt"
    shell:
        """
        source paths.sh
        echo "Listing .fq, .fastq, .gz, .sam, .bam, .bed, .msh, .fasta, .gfa files in PROGRAMS directory:" > {output.log}
        find path_prog_prefix -type f | grep -E '(\.fq|\.fastq|\.sam|\.bam|\.bed|\.msh|\.fasta|\.gfa)$' >> {output.log}
        echo "" >> {output.log}
        """

rule concatenate_logs:
    input:
        reads="logs/reads_log.txt",
        data="logs/data_log.txt"
        #outputs="logs/outputs_log.txt"
    output:
        log="logs/file_log.txt"
    shell:
        """
        cat {input.reads} {input.data} > {output.log}
        """


##### load rules #####
include: "rules/00-trimming_reads.smk"
include: "rules/01-quality_control_reads.smk" 



###############################################


        #expand(f"{path_out_prefix}/00-MASH/{{sample}}_combined.tbl", path_out_prefix=path_out_prefix, sample=get_combined_samples()),
        #expand(f"{path_out_prefix}/00-MASH/{{sample}}_screen.out", path_out_prefix=path_out_prefix, sample=get_combined_samples()),
        #expand(f"{path_out_prefix}/00-MASH/{{sample}}_mash_plot.png", path_out_prefix=path_out_prefix, sample=get_combined_samples())
        # Uncomment the following lines when you want to include them in the execution
        # expand("{path_out_prefix}/00-JELLYFISH/{sample}_jellyfishcount.jf", sample=get_combined_samples()),
        # expand("{path_out_prefix}/00-JELLYFISH/{sample}_jellyfish_histo.histo", sample=get_combined_samples()),
        # expand("{path_out_prefix}/00-GENOMESCOPE/{sample}_plot.png", sample=get_combined_samples())

#rule log_outputs_directory:
#    input:
#        "paths.sh"
#    output:
#        log="logs/outputs_log.txt"
#    shell:
#        """
#        source paths.sh
#        echo "Listing .fq, .fastq, .gz, .sam, .bam, .bed, .msh, .fasta, .gfa files in OUTPUTS directory:" > {output.log}
#        find $path_out_prefix -type f | grep -E '(\.fq|\.fastq|\.sam|\.bam|\.bed|\.msh|\.fasta|\.gfa)$' >> {output.log}
#        echo "" >> {output.log}
#       """














    #       {input.temporary} \ {input.outputs} 
    # {input.programs} \
    # {input.experiments} \
#find . -type f -print0 | grep -E '\\.(fq|fastq|gz|sam|bam|bed|msh|fasta|gfa)$' >> {output.log}

#include: "rules/plots.smk"
#include: "rules/reference.smk"
##
#include: "rules/quality_control_reads_jellyfish.smk"
#include: "rules/quality_control_assembly.smk" 
#include: "rules/trimming.smk"
#include: "rules/denovo.smk"

#include: "rules/mapping_illumina.smk"
#include: "rules/variant_calling.smk"

#include: "rules/pangenomes_plots.smk"

#include: "rules/mitoVGP_conda_env_ONT.smk"
#include: "rules/mitoVG_conda_env_pacbio.smk"


#include: "rules/annotations.smk"
#include: "rules/pangenomes_annotations.smk"



# End
