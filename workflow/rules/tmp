rule process_forward_reads:
    input:
        lambda wildcards: [
            f"{config['samples']['CGAF']['paths'][i]}/{config['samples']['CGAF']['files'][i]}"
            for i in range(len(config['samples']['CGAF']['coverages']))
            if config['samples']['CGAF']['coverages'][i] == '30' and
               config['samples']['CGAF']['orientations'][i] == 'R1'
        ]
    output:
        "processed/{sample}_fwd_reads_processed.fq.gz"
    shell:
        """
        # Your shell commands here
        """


rule remove_hifi_adapters:
    input:
        raw_read_hifi = ""
    output: 
        trimmed_hifi_reads = {}
      shell:
      """ 
       echo "Trimming reads for sample: {input}" >> log_file.txt
       seqtk trimfq -b 20 -e 20 {input}.fastq > {output}_trimmed.fastq
      """
   


rule adapter_removal: # Eventually remove HiC adapter DNA sequences
    input:
        read1 = "{path_reads_prefix_reads}{sample}_R1.fastq.gz",
        read2 = "{path_reads_reads}{sample}_R2.fastq.gz"
    output:
        out1 = "{path_prefix_reads_trimmed}{sample}_trimmed_R1.fastq.gz",
        out2 = "{path_prefix_reads_trimmed}{sample}_trimmed_R2.fastq.gz"
    threads: config['CPUS']
    shell:
        """
        mkdir -p {config[path_prefix_step1_trimming]}AdaptRemoval
        {config[path_prefix_programs]}{config[progAdapterRemoval]} \
            --file1 {input.read1} \
            --file2 {input.read2} \
            --gzip \
            --output1 {output.out1} \
            --output2 {output.out2} \
            --threads {threads}
        """

#rule all_adapter_removal:
#    input:
#        expand(f"{config['path_prefix_step1_trimming']}AdaptRemoval/{{sample}}_R1_trimmed.fq.gz", sample=config['shortNames'].keys()),
#        expand(f"{config['path_prefix_step1_trimming']}AdaptRemoval/{{sample}}_R2_trimmed.fq.gz", sample=config['shortNames'].keys())

print (config['samples'])
# The following is equivalent to what snakemake does with the configuration file:
#config = yaml.load(config_text)
#config
# Manually load an additional configuration file
#with open("config_active.yaml") as f:
#    config_active = yaml.safe_load(f)


###############################################


        #expand(f"{path_out_prefix}/00-MASH/{{sample}}_combined.tbl", path_out_prefix=path_out_prefix, sample=get_combined_samples()),
        #expand(f"{path_out_prefix}/00-MASH/{{sample}}_screen.out", path_out_prefix=path_out_prefix, sample=get_combined_samples()),
        #expand(f"{path_out_prefix}/00-MASH/{{sample}}_mash_plot.png", path_out_prefix=path_out_prefix, sample=get_combined_samples())
        # Uncomment the following lines when you want to include them in the execution
        # expand("{path_out_prefix}/00-JELLYFISH/{sample}_jellyfishcount.jf", sample=get_combined_samples()),
        # expand("{path_out_prefix}/00-JELLYFISH/{sample}_jellyfish_histo.histo", sample=get_combined_samples()),
        # expand("{path_out_prefix}/00-GENOMESCOPE/{sample}_plot.png", sample=get_combined_samples())

#rule log_outputs_directory:
#    input:
#        "paths.sh"
#    output:
#        log="logs/outputs_log.txt"
#    shell:
#        """
#        source paths.sh
#        echo "Listing .fq, .fastq, .gz, .sam, .bam, .bed, .msh, .fasta, .gfa files in OUTPUTS directory:" > {output.log}
#        find $path_out_prefix -type f | grep -E '(\.fq|\.fastq|\.sam|\.bam|\.bed|\.msh|\.fasta|\.gfa)$' >> {output.log}
#        echo "" >> {output.log}
#       """














    #       {input.temporary} \ {input.outputs} 
    # {input.programs} \
    # {input.experiments} \
#find . -type f -print0 | grep -E '\\.(fq|fastq|gz|sam|bam|bed|msh|fasta|gfa)$' >> {output.log}

#include: "rules/plots.smk"
#include: "rules/reference.smk"
##
#include: "rules/quality_control_reads_jellyfish.smk"
#include: "rules/quality_control_assembly.smk" 
#include: "rules/trimming.smk"
#include: "rules/denovo.smk"

#include: "rules/mapping_illumina.smk"
#include: "rules/variant_calling.smk"

#include: "rules/pangenomes_plots.smk"

#include: "rules/mitoVGP_conda_env_ONT.smk"
#include: "rules/mitoVG_conda_env_pacbio.smk"


#include: "rules/annotations.smk"
#include: "rules/pangenomes_annotations.smk"



# End
def get_combined_samples():
    species = get_species()
    sex = get_sex()
    method = get_method()
    orientation = get_orientation()
    return ["{}_{}_{}_{}".format(s, sx, m, o) for s in species for sx in sex for m in method for o in orientation]

def get_sample(wildcards): #Get_sample_prefix
    # This function now assumes each sample is a key in the config that 
    # corresponds to a prefix without a file extension
    return f"{wildcards.species}_{wildcards.sex}_{wildcards.method}_{wildcards.orientation}"


def get_available_wildcards():
    species_set = set()
    sex_set = set()
    method_set = set()
    orientation_set = set()
    pattern = re.compile(r'(\w+)_(\w+)_(\w+)_(\w+).fq.gz$')

    for filename in os.listdir(path_reads_prefix):
        match = pattern.match(filename)
        if match:
            species, sex, method, orientation = match.groups()
            species_set.add(species)
            sex_set.add(sex)
            method_set.add(method)
            orientation_set.add(orientation)

    return species_set, sex_set, method_set, orientation_set


def get_existing_reads_files():
    reads_files = []
    for read_file in glob.glob(f"{path_reads_prefix}/*.fq.gz"):
        if os.path.isfile(read_file):
            # Remove the .fq.gz extension and append the _trimmed.fq.gz extension
            trimmed_base = read_file.rsplit('.fq.gz', 1)[0]
            trimmed_file = f"{trimmed_base}_trimmed.fq.gz"
            reads_files.append(trimmed_file)
    return reads_files

       #expand("{path_reads_prefix}/{sample}_trimmed.fq.gz", path_reads_prefix=path_reads_prefix) #line 82
       #get_existing_reads_files()
    # Add additional lines for other output files as needed

#rule all_adapter_removal:
#    input:
#       expand(f"{path_prefix_reads}/{{sample}}_trimmed.fq.gz", sample=get_combined_samples())




# Note: Make sure that 'config' is loaded either in your main Snakefile or in this file.

def populate_wildcard_lists():
    species_list = set()
    sex_list = set()
    method_list = set()
    orientation_list = set()

    pattern = re.compile(r'(\w+)_(\w+)_(\w+)_(\w+).fq.gz$')
    for filename in os.listdir(path_reads_prefix):
        match = pattern.match(filename)
        if match:
            species, sex, method, orientation = match.groups()
            species_list.add(species)
            sex_list.add(sex)
            method_list.add(method)
            orientation_list.add(orientation)

    return {
        'species': list(species_list),
        'sex': list(sex_list),
        'method': list(method_list),
        'orientation': list(orientation_list)
    }

# Call the function and store the results in variables
wildcards = populate_wildcard_lists()
SPECIES = wildcards['species']
SEX = wildcards['sex']
METHODS = wildcards['method']
ORIENTATIONS = wildcards['orientation']
rule adapter_removal:
    input:
        read1 = "{path_reads_prefix}/{species}_{sex}_{method}_FWD.fq.gz",
        read2 = "{path_reads_prefix}/{species}_{sex}_{method}_REV.fq.gz"
    output:
        out1 = "{path_reads_prefix}/{species}_{sex}_{method}_FWD_trimmed.fq.gz",
        out2 = "{path_reads_prefix}/{species}_{sex}_{method}_REV_trimmed.fq.gz"
    conda:
        "rules/quality_control_reads.yaml"
    shell:
        """
        AdapterRemoval \
            --file1 {input.read1} \
            --file2 {input.read2} \
            --gzip \
            --output1 {output.out1} \
            --output2 {output.out2} \
            --threads {threads}
        """

        expand("{path_out_prefix}/00-MASH/{{sample}}_mash_plot.png",
               path_out_prefix=path_out_prefix,
               sample=["CM_M_HIFI_None", "CG_F_HIFI_None"] +
                      ["CG_F_ILLUMINA_" + o for o in ORIENTATIONS_PE] +
                      ["CM_F_ILLUMINA_" + o for o in ORIENTATIONS_PE] +
                      ["CM_M_ILLUMINA_" + o for o in ORIENTATIONS_PE])


def get_unique_values(key):
    values = set()
    for species in config["samples"].values():
        for sample in species.values():
            value = sample.get(key)
            if value is not None:
                values.add(value)
    return list(values)

def get_unique_values_references(key):
    values = set()
    for sample in config["references"]["references"].values():
        values.update(sample.get(key, []))
    return list(values)

def get_sample_ids():
    return get_unique_values('sample_id')

def get_reference_accession():
    return get_unique_values('assembly_accession')

def get_species_file_prefix():
    return get_unique_values('file_prefixes')

def get_species_long():
    return get_unique_values('species_long')

def get_species():
    return get_unique_values('species')

def get_sex():
    return get_unique_values('sex')

def get_method():
    return get_unique_values('method')

def get_orientation():
    return get_unique_values('orientation')


# Rule to print function outputs
rule print_function_outputs:
    output:
        "expand.keys.txt"
        run:
        with open(output[0], 'w') as f_out:
            # List of functions to display output from
            functions_to_run = [
                get_sample_ids,
                get_reference_accession,
                get_species_file_prefix,
                get_species_long,
                get_species,
                get_sex,
                get_method,
                get_orientation,
                get_combined_samples,
                get_existing_reads_files
            ]
            # Iterate over the functions and print their output
            for func in functions_to_run:
                func_name = func.__name__
                func_output = func()
                print(f"Output of {func_name}: {func_output}")
                f_out.write(f"Output of {func_name}: {func_output}\n")

rule fastqc_on_hic:
    input:
        hic_zg=lambda wildcards: f"{path_reads_prefix}/{get_sample(wildcards)}.gz"
    output:
        fastqc_out="{path_out_prefix}/00-FASTQC_TMP/{species}_{sex}_{method}_{orientation}/"
    params:
        tmp_dir="{path_tmp_prefix}/00-FASTQC_TMP/{species}_{sex}_{method}_{orientation}/",
        log="logs/fastqc_on_hic_{wildcards.species}_{wildcards.sex}_{wildcards.method}_{wildcards.orientation}.log"
    conda:
        "quality_control_reads.yaml"  # Replace with the path to your conda environment file
    shell:
        """
        echo "Starting FastQC on HiC data." > {params.log}
        mkdir -p {params.tmp_dir} {output.fastqc_out} && \
        fastqc {input.hic_zg} -d {params.tmp_dir} -o {output.fastqc_out} &>> {params.log}
        echo "FastQC on HiC data completed." >> {params.log}
        """

### Parse and prepare PacBio data

### Parse and prepare PacBio data
rule bam_to_fastq:
    input:
        bam=lambda wildcards: f"{path_reads_prefix}/{get_sample(wildcards)}.bam"
    output:
        fastq="{path_reads_prefix}/{species}_{sex}_{method}_{orientation}_rawreads.fastq"
    params:
        log="logs/bam_to_fastq_{wildcards.species}_{wildcards.sex}_{wildcards.method}_{wildcards.orientation}.log"
    conda:
        "quality_control_reads.yaml"  # Replace with the path to your conda environment file
    shell:
        """
        echo "Converting BAM to FASTQ." > {params.log}
        if [ "{wildcards.method}" == "HIFI" ]; then
            bam2fastq -o {output.fastq} {input.bam} &>> {params.log}
        else
            echo "Unsupported method: {wildcards.method}" >> {params.log}
            exit 1
        fi
        echo "Conversion completed." >> {params.log}
        """

rule remove_hifi_adapters:
    input:
        raw_read_hifi=lambda wildcards: f"{path_reads_prefix}/{get_sample(wildcards)}_rawreads.fastq"
    output:
        trimmed_hifi_reads="{path_reads_prefix}/{sample}_reads.fastq"
    params:
        log="logs/remove_hifi_adapters_{sample}.log"
    conda:
        "envs/quality_control_reads.yaml"  # Replace with the path to your conda environment file
    shell:
        """ 
        echo "Starting adapter removal for HiFi reads." > {params.log}
        if [ "{wildcards.method}" == "HIFI" ]; then
            seqtk trimfq -b 20 -e 20 {input.raw_read_hifi} > {output.trimmed_hifi_reads} &>> {params.log}
        else
            echo "Unsupported method: {wildcards.method}" >> {params.log}
            exit 1
        fi
        echo "Adapter removal completed." >> {params.log}
        """

rule gzip_hifi_fastq:
    input:
        trimmed_hifi_reads=lambda wildcards: f"{path_reads_prefix}/{get_sample(wildcards)}_reads.fastq"
    output:
        fastq="{path_reads_prefix}/{species}_{sex}_{method}_{orientation}_reads.fastq.gz"
    params:
        log="logs/gzip_hifi_fastq_{wildcards.species}_{wildcards.sex}_{wildcards.method}_{wildcards.orientation}.log"
    conda:
        "quality_control_reads.yaml"  # Replace with the path to your conda environment file
    shell:
        """ 
        echo "Starting gzipping of trimmed HiFi reads." > {params.log}
        if [ "{wildcards.method}" == "HIFI" ]; then
            gzip -5 {input.trimmed_hifi_reads} &>> {params.log}
        else
            echo "Unsupported method: {wildcards.method}" >> {params.log}
            exit 1
        fi
        mv {input.trimmed_hifi_reads}.gz {output.fastq}
        echo "Gzipping completed." >> {params.log}
        """
