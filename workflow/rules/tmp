rule process_forward_reads:
    input:
        lambda wildcards: [
            f"{config['samples']['CGAF']['paths'][i]}/{config['samples']['CGAF']['files'][i]}"
            for i in range(len(config['samples']['CGAF']['coverages']))
            if config['samples']['CGAF']['coverages'][i] == '30' and
               config['samples']['CGAF']['orientations'][i] == 'R1'
        ]
    output:
        "processed/{sample}_fwd_reads_processed.fq.gz"
    shell:
        """
        # Your shell commands here
        """


rule remove_hifi_adapters:
    input:
        raw_read_hifi = ""
    output: 
        trimmed_hifi_reads = {}
      shell:
      """ 
       echo "Trimming reads for sample: {input}" >> log_file.txt
       seqtk trimfq -b 20 -e 20 {input}.fastq > {output}_trimmed.fastq
      """
   


rule adapter_removal: # Eventually remove HiC adapter DNA sequences
    input:
        read1 = "{path_reads_prefix_reads}{sample}_R1.fastq.gz",
        read2 = "{path_reads_reads}{sample}_R2.fastq.gz"
    output:
        out1 = "{path_prefix_reads_trimmed}{sample}_trimmed_R1.fastq.gz",
        out2 = "{path_prefix_reads_trimmed}{sample}_trimmed_R2.fastq.gz"
    threads: config['CPUS']
    shell:
        """
        mkdir -p {config[path_prefix_step1_trimming]}AdaptRemoval
        {config[path_prefix_programs]}{config[progAdapterRemoval]} \
            --file1 {input.read1} \
            --file2 {input.read2} \
            --gzip \
            --output1 {output.out1} \
            --output2 {output.out2} \
            --threads {threads}
        """

#rule all_adapter_removal:
#    input:
#        expand(f"{config['path_prefix_step1_trimming']}AdaptRemoval/{{sample}}_R1_trimmed.fq.gz", sample=config['shortNames'].keys()),
#        expand(f"{config['path_prefix_step1_trimming']}AdaptRemoval/{{sample}}_R2_trimmed.fq.gz", sample=config['shortNames'].keys())

print (config['samples'])
# The following is equivalent to what snakemake does with the configuration file:
#config = yaml.load(config_text)
#config
# Manually load an additional configuration file
#with open("config_active.yaml") as f:
#    config_active = yaml.safe_load(f)


###############################################


        #expand(f"{path_out_prefix}/00-MASH/{{sample}}_combined.tbl", path_out_prefix=path_out_prefix, sample=get_combined_samples()),
        #expand(f"{path_out_prefix}/00-MASH/{{sample}}_screen.out", path_out_prefix=path_out_prefix, sample=get_combined_samples()),
        #expand(f"{path_out_prefix}/00-MASH/{{sample}}_mash_plot.png", path_out_prefix=path_out_prefix, sample=get_combined_samples())
        # Uncomment the following lines when you want to include them in the execution
        # expand("{path_out_prefix}/00-JELLYFISH/{sample}_jellyfishcount.jf", sample=get_combined_samples()),
        # expand("{path_out_prefix}/00-JELLYFISH/{sample}_jellyfish_histo.histo", sample=get_combined_samples()),
        # expand("{path_out_prefix}/00-GENOMESCOPE/{sample}_plot.png", sample=get_combined_samples())

#rule log_outputs_directory:
#    input:
#        "paths.sh"
#    output:
#        log="logs/outputs_log.txt"
#    shell:
#        """
#        source paths.sh
#        echo "Listing .fq, .fastq, .gz, .sam, .bam, .bed, .msh, .fasta, .gfa files in OUTPUTS directory:" > {output.log}
#        find $path_out_prefix -type f | grep -E '(\.fq|\.fastq|\.sam|\.bam|\.bed|\.msh|\.fasta|\.gfa)$' >> {output.log}
#        echo "" >> {output.log}
#       """














    #       {input.temporary} \ {input.outputs} 
    # {input.programs} \
    # {input.experiments} \
#find . -type f -print0 | grep -E '\\.(fq|fastq|gz|sam|bam|bed|msh|fasta|gfa)$' >> {output.log}

#include: "rules/plots.smk"
#include: "rules/reference.smk"
##
#include: "rules/quality_control_reads_jellyfish.smk"
#include: "rules/quality_control_assembly.smk" 
#include: "rules/trimming.smk"
#include: "rules/denovo.smk"

#include: "rules/mapping_illumina.smk"
#include: "rules/variant_calling.smk"

#include: "rules/pangenomes_plots.smk"

#include: "rules/mitoVGP_conda_env_ONT.smk"
#include: "rules/mitoVG_conda_env_pacbio.smk"


#include: "rules/annotations.smk"
#include: "rules/pangenomes_annotations.smk"



# End
def get_combined_samples():
    species = get_species()
    sex = get_sex()
    method = get_method()
    orientation = get_orientation()
    return ["{}_{}_{}_{}".format(s, sx, m, o) for s in species for sx in sex for m in method for o in orientation]

def get_sample(wildcards): #Get_sample_prefix
    # This function now assumes each sample is a key in the config that 
    # corresponds to a prefix without a file extension
    return f"{wildcards.species}_{wildcards.sex}_{wildcards.method}_{wildcards.orientation}"


def get_available_wildcards():
    species_set = set()
    sex_set = set()
    method_set = set()
    orientation_set = set()
    pattern = re.compile(r'(\w+)_(\w+)_(\w+)_(\w+).fq.gz$')

    for filename in os.listdir(path_reads_prefix):
        match = pattern.match(filename)
        if match:
            species, sex, method, orientation = match.groups()
            species_set.add(species)
            sex_set.add(sex)
            method_set.add(method)
            orientation_set.add(orientation)

    return species_set, sex_set, method_set, orientation_set


def get_existing_reads_files():
    reads_files = []
    for read_file in glob.glob(f"{path_reads_prefix}/*.fq.gz"):
        if os.path.isfile(read_file):
            # Remove the .fq.gz extension and append the _trimmed.fq.gz extension
            trimmed_base = read_file.rsplit('.fq.gz', 1)[0]
            trimmed_file = f"{trimmed_base}_trimmed.fq.gz"
            reads_files.append(trimmed_file)
    return reads_files

       #expand("{path_reads_prefix}/{sample}_trimmed.fq.gz", path_reads_prefix=path_reads_prefix) #line 82
       #get_existing_reads_files()
    # Add additional lines for other output files as needed

#rule all_adapter_removal:
#    input:
#       expand(f"{path_prefix_reads}/{{sample}}_trimmed.fq.gz", sample=get_combined_samples())




# Note: Make sure that 'config' is loaded either in your main Snakefile or in this file.

